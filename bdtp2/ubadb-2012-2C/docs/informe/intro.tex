\section{Introducci\'on}

Este trabajo pr\'actico analiza diferentes estrategias que se pueden utilizar para optimizar el uso del Buffer Manager en un motor de una base de datos. El Buffer Manager es el componente que se encarga de obtener del disco las p\'aginas que se necesitan de la base de datos y colocarlas en memoria, manteni\'endolas en un componente que hace las veces de cach\'e (el \textit{buffer pool}). Obviamente, la cantidad de p\'aginas que este componente puede almacenar es limitada, es por eso que el Buffer Manager tiene que constantemente desalojar p\'aginas del buffer pool a la hora de subir nuevas. 

Cu\'ales son las p\'aginas que el buffer manager decida desalojar es importante porque buscar p\'aginas en disco es mucho m\'as costoso que buscarlas en memoria, por lo tanto, es deseable que se maximice el n\'umero de p\'aginas que al consultar se encuentran en memoria y el buffer manager no debe bajar a disco (o sea, la cantidad de \textit{hits}), y, a la inversa, reducir el n\'umero de p\'aginas que al ser consultadas deben ser buscadas en disco porque no se encuentran en memoria (\textit{misses})

Por lo tanto, es de especial inter\'es encontrar un algoritmo que desaloje las p\'aginas que no van a ser usadas en el futuro y que mantenga en memoria las que s\'i lo ser\'an. Obviamente, encontrar el algoritmo perfecto es imposible dado que no sabemos qu\'e paginas van a ser consultadas en el futuro, el objetivo es encontrar la mejor heur\'istica que nos d\'e el mejor \textit{hit ratio} posible (porcentaje de hits sobre total de consultas)

\section{Algoritmos simples}

Para el trabajo, la c\'atedra proporcion\'o el algoritmo de reemplazo FIFO (\textit{first in, first out}), que es un algoritmo bastante trivial, el cual desaloja la p\'agina libre (o sea, que no se encuentra \textit{pinned}, esto es, que no est\'a actualmente en uso, las p\'aginas en uso, por definici\'on, no pueden ser desalojadas de memoria hasta que sean liberadas) que tiene fecha de ingreso al buffer pool m\'as antigua.

Un algoritmo similar es el algoritmo LRU (\textit{least recently used}), el cual en vez de tener en cuenta el instante de ingreso al buffer pool, tiene en cuenta la fecha de \'ultimo uso. Por lo tanto, una p\'agina que ingres\'o a la cola antes que otra pero que fue liberada luego, va a tener una fecha de \'ultimo uso m\'as reciente. El algoritmo LRU desaloja la p\'agina libre con fecha de \'ultimo uso m\'as antigua.

Casi id\'entico es el algoritmo MRU (\textit{most recently used}), pero \'este al buscar la fecha de \'ultimo uso, en vez de buscar y desalojar la m\'as antigua, lo hace con la m\'as nueva.

Cada uno de estos algoritmos tiene ventajas y desventajas, situaciones en los que se comportan muy bien y otras en los que son muy poco \'utiles y no proporcionan (o casi no proporcionan) hits, con lo cual la ventaja de utilizar un cach\'e se anula. Por ejemplo, el algoritmo LRU funciona muy bien cuando se accede muchas veces a las mismas p\'aginas, puesto que al ser usadas, se "resetea" su estad\'ia en el buffer pool, y por lo tanto, van a permanecer m\'as, con lo que si vuelven a ser usadas van a seguir dando hits. Pero por el contrario, LRU es un algoritmo muy malo cuando se hace, por ejemplo, un \textit{file scan}), o sea, una barrida de toda una tabla, que puede tener much\'isimos registros, probablemente m\'as que los que entran en el buffer pool, con lo que al usar una estrategia LRU cuando se hace un file scan escencialmente se guardan datos en el buffer pool que seran expulsados una y otra vez del mismo y probablemente nunca se obtenga un hit.

De manera inversa, el MRU funciona muy bien cuando se leen muchas p\'aginas que no se van a usar en el futuro como en un file scan, porque ser\'an removidas apenas entran en memoria, pero el inconveniente que presenta es que tiene muy poco recambio, las p\'aginas que est\'an hace mucho tiempo en el buffer pool y no se vuelvan a usar permanecer\'an ah\'i por mucho tiempo.

\section{Algoritmo Touch Count}

El algoritmo \textit{Touch Count} es un algortimo creado para evitar estos problemas, existen muchas versiones del mismo pero la que nos interesa es la implementada por Oracle. En el mismo, el buffer pool se divide en dos mitades, una regi\'on fr\'ia y una caliente (por defecto, las mitades son iguales, esto puede cambiarse alterando un par\'ametro). La idea del algoritmo es que en la regi\'on caliente permanezcan las p\'aginas que se reusan (las que dan hits) y en la regi\'on fr\'ia las que no lo hacen. Para esto, en cada p\'agina se almacena el ep\'onimo Touch Count, que representa la cantidad de veces que la p\'agina fue referenciada (interpretamos referenciada como la cantidad de veces que se le hace pin y/o unpin), este count se aumenta cuando se referencia a la p\'agina pero \'esta no se mueve de su lugar cuando esto pasa. 

Al insertar una p\'agina nuevo, se la coloca en la mitad de la lista, o sea, en la cola de la regi\'on fr\'ia, con esto se prejuzga que la misma no va a tener hits, se espera que demuestre que va a ser reutilizada para entrar en la regi\'on caliente

Existen dos instancias en las que el algoritmo chequea los touch counts de las p\'aginas: cuando busca un bloque libre en el buffer pool para colocar una p\'agina y cuando busca una p\'agina para quitar del pool. En estos casos, el algoritmo recorre todas las p\'aginas de la regi\'on fr\'ia, las que encuentra con un touch count mayor a 2 (nuevamente, \'este es un par\'ametro por defecto que puede modificarse) son extra\'idas y movidas a la cola de la regi\'on caliente. Como las regiones tienen el mismo tama\~no (asumiendo tama\~no por defecto), el migrar p\'aginas desde la regi\'on fr\'ia a la caliente hace que las p\'aginas del tope de la regi\'on caliente pasen a la fr\'ia. En este caso, no importa cuanto fuera su touch count, \'este se resetea a 1 (par\'ametro por defecto, modificable), con lo que \'estas p\'aginas deben "demostrar" nuevamente que pueden recibir hits. Asimismo, las p\'aginas migradas a la regi\'on caliente ven reseatado su hit count a 0 (par\'ametro por defecto, modificable), pero esto en ning\'un momento notamos que influya en algo, puesto que, de acuerdo con la bibliograf\'ia consultada, en ning\'un momento el algoritmo mira el touch count de las p\'aginas en la regi\'on caliente.

Existe un \'ultimo elemento a tener en cuenta, y es el hecho de que no todas las referencias a una p\'agina aumentan el touch count. Seg\'un Oracle, es com\'un que  p\'aginas sean referenciadas muchas veces en un per\'iodo corto de tiempo, pero luego no sean usadas nunca m\'as. Si no se tuviera esta condici\'on, este incremento r\'apido del touch count las colocar\'ia en la regi\'on caliente, desde donde no ser\'ia f\'acil desalojarlas. Por lo tanto, al incrementarse el touch count sobre una p\'agina, se implementa un per\'iodo de tiempo donde la misma no ve incrementado el mismo no importa cu\'antas veces sea referenciada. Este per\'iodo por defecto es de 3 segundos, y por supuesto puede ser modificado a conveniencia.

\section{Implementaci\'on}

En nuestra implementaci\'on, no tuvimos en cuenta el per\'iodo de 3 segundos donde no se incrementan los touch counts, puesto que las corridas iban a demorar menos de 3 segundos en total de todas maneras, fuera de eso, las implementaciones de LRU, MRU y Touch Count fueron respetando las especificaciones dadas anteriormente. Para LRU y MRU, bast\'o con agregar una nueva implementaci\'on de las clases Buffer Frame y PageReplacementStrategy; por el contrario, para Touch Count, adem\'as de implementar estas dos clases, hubo que modificar el Buffer Pool, ya que necesit\'abamos acceder a la lista de p\'aginas fr\'ias/calientes al insertar una nueva p\'agina, lo que no es posible desde la estrategia. Por lo tanto, para correr LRU y MRU basta con editar en MainEvaluator la l\'inea que especifica la estrategia a usar. Para correr Touch Count, adem\'as de esta l\'inea, hay que modificar la que selecciona el buffer pool para que utilice TouchCountBufferPool en vez de SingleBufferPool.

La implementaci\'on del Touch Count agrega una lista de PageId al buffer pool, que es donde mantenemos las p\'aginas organizadas en regi\'on caliente y fr\'ia, cada vez que se ejecuta el agregado de una p\'agina o se va a buscar una v\'ictima corremos el m\'etodo migrate, que es el que pasa las p\'aginas de la regi\'on fr\'ia con hits a la caliente, y resetea los counts de las p\'aginas que cambian de regi\'on.

